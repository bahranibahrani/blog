<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Windows Terminal Dengan Oh-My-Posh | My Blog</title>
<meta name=keywords content><meta name=description content="Desc Text."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.bahrani.my.id/docs/terminal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Windows Terminal Dengan Oh-My-Posh"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bahrani.my.id/docs/terminal/"><meta property="og:image" content="https://blog.bahrani.my.id/%3Cimage%20path/url%3E"><meta property="article:section" content="docs"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.bahrani.my.id/%3Cimage%20path/url%3E"><meta name=twitter:title content="Windows Terminal Dengan Oh-My-Posh"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://blog.bahrani.my.id/docs/"},{"@type":"ListItem","position":2,"name":"Windows Terminal Dengan Oh-My-Posh","item":"https://blog.bahrani.my.id/docs/terminal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Windows Terminal Dengan Oh-My-Posh","name":"Windows Terminal Dengan Oh-My-Posh","description":"Desc Text.","keywords":[],"articleBody":"Tes apa yang ada here.\nPlugin README Dropbox [plugins/dropbox/README.md][PlDb] GitHub [plugins/github/README.md][PlGh] Google Drive [plugins/googledrive/README.md][PlGd] OneDrive [plugins/onedrive/README.md][PlOd] Medium [plugins/medium/README.md][PlMe] Google Analytics [plugins/googleanalytics/README.md][PlGa] print(\"heloword\") In the code snippet above, we define an unbuffered channel called done. The channel is unbuffered because we are not assigning any capacity/size to the channel. We will take a look at buffered channels in another example later. The main characteristic of an unbuffered channel is that it blocks until another goroutine executes a corresponding receive on the same channel, causing the sending and receiving goroutines to be “synchronous”. With the unbuffered channel in the example above, we can ensure that the program waits for the background goroutine to finish before exiting. You can find the code example from the book here.\nUnbuffered vs. buffered channels Let’s have a look at an example from the book where an unbuffered channel might lead to a problem.\nfunc mirroredQuery() string { responses := make(chan string) go func() { responses \u003c- \"response 1\" }() go func() { responses \u003c- \"response 2\" }() go func() { responses \u003c- \"response 3\" }() return \u003c-responses // return the quickest response } With unbuffered channels, there might be a scenario like the above where the two slower goroutines (as to which of the three would be the fastest is non-deterministic) would be stuck trying to send their responses on a channel from which no goroutine will ever receive. This is known as a goroutine leak and it is important to ensure that the goroutines terminate themselves when no longer needed since leaked goroutines are not automatically collected.\nHowever, we would not encounter a goroutine leak if we use a buffered channel instead as such: responses := make(chan string, 3) where we assign a capacity of 3 to the channel. That buffered channel would hold up to three string values and block until a space is made available by another goroutine’s receive. And even if the sending channel closes, the values queued up in the channel can be handled later by the receiving channels.\nAlthough unbuffered channels provide stronger synchronization guarantees, it would require prudence on our end to avoid goroutine leaks. If the synchronization does not matter as much and you know the upper bound on the number of values that will be sent on the channel, a buffered channel could be a better option. However, it is worth noting that failure to allocate sufficient buffer capacity would cause the program to deadlock.\nAs we looked at an example of a goroutine leak, you might have also wondered if we have to close all the channels as well. The answer is that you do not need to close every channel unless it is important to tell the receiving goroutines that all data have been sent. Channels that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. However, closing an already-closed channel causes a panic, as does closing a nil channel.\nRunning loops in parallel At first glance, looping in parallel might appear to be as simple as:\nfunc parallelLoop() { for _, f := range filenames { go func(f string) { // ... }(f) } } However, when you run the function above, you will observe that the function exits almost immediately. The above doesn’t work because parallelLoop() returns before it has finished all its work. We have to change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel as below:\nfunc parallelLoop() { ch := make(chan struct{}) for _, f := range filenames { go func(f string) { // ... ch \u003c- struct{}{} }(f) } for range filenames { \u003c-ch } } One other thing worth highlighting is that the f is passed into the goroutine as an explicit argument as such: go func(f string){...}(f) and not directly used in the goroutine. Explicit parameters are used for goroutines in a loop to ensure that we use the value of f that is current when the go statement is executed.\nHowever, the above example does not take error handling into consideration. Now let’s have a look at the idiomatic approach to looping in parallel using the sync.WaitGroup and handling errors appropriately:\nfunc makeThumbnails(filesnames \u003c-chan string) int64 { sizes := make(chan int64) var wg sync.WaitGroup for f := range filenames { wg.Add(1) go func(f string) { defer wg.Done() // run operations to retrieve the size of the file sizes \u003c- size }(f) } // closer go func() { wg.Wait() close(sizes) } var total int64 for size := range sizes { total += size } return total } Above is a snippet of code where we retrieve the size of different files in parallel and compute the total size. The example used in the book can be found here. There are a few things we want to pay attention from the above:\nwg.Add(1) must be called before the worker goroutine starts, not within it—this ensures that the Add happens before the closer goroutine calls Wait defer is used on wg.Done() to ensure that Done is called even in the error cases The closer goroutine that waits for the workers must be created before the closing of the sizes channel The closer goroutine must be concurrent with the loop over sizes If the wait operation was placed before the loop in the main goroutine: it would never end If the wait operation was placed after the loop in the main goroutine: the loop would never terminate because there is nothing closing the sizes channel and the wait operation will be unreachable Unbounded parallelism If there is a limiting factor in the system, such as the number of CPU cores, the number of spindles and heads for local disk I/O operations, or the bandwidth of the network, we want to limit the number of parallel uses of the resource to match the level of parallelism that is available.\nWe can limit parallelism using a buffered channel of capacity n to model a concurrency primitive called a counting semaphore. Conceptually sending a value into the channel acquires a token and receiving a value from the channel releases the token, ensuring that at most n sends can occur without an intervening receive. Let’s have a look at an example:\nvar tokens = make(chan struct{}, 20) func doSomething() { tokens \u003c- struct{}{} // acquire the token // .. \u003c-tokens // release the token } Alternatively, you can use the golang semaphore package and call Acquire and Release on the semaphore that is equivalent of the token concept above.\nvar sem = semaphore.NewWeighted(int64(10)) sem.Acquire(ctx, 1) // equivalent to sem \u003c- 1 (using channel approach) sem.Release(1) // equivalent to \u003c- sem (using channel approach) There is a blog post that covers semaphore in greater detail here.\nMultiplexing with select \u0026 cancellation The select statement comes in handy when we need to wait for an event on one of the many channels. The select statement can be used with a ticker to run a loop every n seconds/minutes/hours as below:\nticker := time.NewTicker(5 * time.Second) go func() { for ... { // some operations select { case \u003c- ticker.C: case \u003c- done: return default: } } } Notice how we have a case for a receive operation on a done channel. That is useful when want the main goroutine to tell the other goroutines (above goroutine in this case) to abandon the values they are trying to send. Otherwise those goroutines with work left will be stuck trying to send their responses on a channel from which no goroutine will ever receive, leading to resource leak as mentioned earlier. In order for that to work, we will need to close the done channel at the end of the main() as done below:\nfunc main() { // Set up a done channel that's shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit done := make(chan struct{}) defer close(done) // some operations go func(done \u003c-chan struct{}){ ... }(done) // done will be closed by the deferred call } Here are a few other details about the multiplexing with the select statement that you might find useful:\nIf multiple cases are ready, select picks one at a random. If there is a case in the select statement where the channel can optionally be nil (depending on the flag passed in), the case is effectively disabled I hope this post has provided some context for you to get started with concurrency in Go. If you would like to learn more about them, make sure you check out Chapter 8: Goroutines and Channels of the Go Programming Language book as well as The Go Blog on Go Concurrency Patterns.\n","wordCount":"1465","inLanguage":"en","image":"https://blog.bahrani.my.id/%3Cimage%20path/url%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bahrani.my.id/docs/terminal/"},"publisher":{"@type":"Organization","name":"My Blog","logo":{"@type":"ImageObject","url":"https://blog.bahrani.my.id/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bahrani.my.id/ accesskey=h title="Home (Alt + H)"><img src=https://blog.bahrani.my.id/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.bahrani.my.id/categories/ title=categories><span>categories</span></a></li><li><a href=https://blog.bahrani.my.id/tags/ title=tags><span>tags</span></a></li><li><a href=https://blog.bahrani.my.id/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bahrani.my.id/>Home</a>&nbsp;»&nbsp;<a href=https://blog.bahrani.my.id/docs/>Docs</a></div><h1 class="post-title entry-hint-parent">Windows Terminal Dengan Oh-My-Posh</h1><div class=post-description>Desc Text.</div><div class=post-meta>7 min&nbsp;·&nbsp;1465 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/docs/Terminal.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#tes-apa-yang-ada>Tes apa yang ada</a></li><li><a href=#unbuffered-vs-buffered-channels>Unbuffered vs. buffered channels</a></li><li><a href=#running-loops-in-parallel>Running loops in parallel</a></li><li><a href=#unbounded-parallelism>Unbounded parallelism</a></li><li><a href=#multiplexing-with-select--cancellation>Multiplexing with select & cancellation</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=tes-apa-yang-ada>Tes apa yang ada<a hidden class=anchor aria-hidden=true href=#tes-apa-yang-ada>#</a></h3><p><a href=https://nodesource.com/products/nsolid><img loading=lazy src=https://cldup.com/dTxpPi9lDf.thumb.png alt=N|Solid>
</a><a href=https://github.com/bahrani667>here</a>.</p><table><thead><tr><th>Plugin</th><th>README</th></tr></thead><tbody><tr><td>Dropbox</td><td>[plugins/dropbox/README.md][PlDb]</td></tr><tr><td>GitHub</td><td>[plugins/github/README.md][PlGh]</td></tr><tr><td>Google Drive</td><td>[plugins/googledrive/README.md][PlGd]</td></tr><tr><td>OneDrive</td><td>[plugins/onedrive/README.md][PlOd]</td></tr><tr><td>Medium</td><td>[plugins/medium/README.md][PlMe]</td></tr><tr><td>Google Analytics</td><td>[plugins/googleanalytics/README.md][PlGa]</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;heloword&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>In the code snippet above, we define an unbuffered channel called <code>done</code>. The channel is unbuffered because we are not assigning any capacity/size to the channel. We will take a look at buffered channels in another example later. The main characteristic of an unbuffered channel is that it blocks until another goroutine executes a corresponding receive on the same channel, causing the sending and receiving goroutines to be &ldquo;synchronous&rdquo;. With the unbuffered channel in the example above, we can ensure that the program waits for the background goroutine to finish before exiting. You can find the code example from the book <a href=https://github.com/adonovan/gopl.io/blob/master/ch8/netcat3/netcat.go#L17-L31>here</a>.</p><h3 id=unbuffered-vs-buffered-channels>Unbuffered vs. buffered channels<a hidden class=anchor aria-hidden=true href=#unbuffered-vs-buffered-channels>#</a></h3><p>Let&rsquo;s have a look at an example from the book where an unbuffered channel might lead to a problem.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mirroredQuery</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>responses</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>responses</span> <span class=o>&lt;-</span> <span class=s>&#34;response 1&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>responses</span> <span class=o>&lt;-</span> <span class=s>&#34;response 2&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>responses</span> <span class=o>&lt;-</span> <span class=s>&#34;response 3&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&lt;-</span><span class=nx>responses</span> <span class=c1>// return the quickest response
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>With unbuffered channels, there might be a scenario like the above where the two slower goroutines (as to which of the three would be the fastest is non-deterministic) would be stuck trying to send their responses on a channel from which no goroutine will ever receive. This is known as a <code>goroutine leak</code> and it is important to ensure that the goroutines terminate themselves when no longer needed since leaked goroutines are not automatically collected.</p><p>However, we would not encounter a <code>goroutine leak</code> if we use a buffered channel instead as such: <code>responses := make(chan string, 3)</code> where we assign a capacity of 3 to the channel. That buffered channel would hold up to three string values and block until a space is made available by another goroutine&rsquo;s receive. And even if the sending channel closes, the values queued up in the channel can be handled later by the receiving channels.</p><p>Although unbuffered channels provide stronger synchronization guarantees, it would require prudence on our end to avoid goroutine leaks. If the synchronization does not matter as much and you know the upper bound on the number of values that will be sent on the channel, a buffered channel could be a better option. However, it is worth noting that failure to allocate sufficient buffer capacity would cause the program to deadlock.</p><p>As we looked at an example of a goroutine leak, you might have also wondered if we have to close all the channels as well. The answer is that you do not need to close every channel unless it is important to tell the receiving goroutines that all data have been sent. Channels that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. However, closing an already-closed channel causes a panic, as does closing a nil channel.</p><h3 id=running-loops-in-parallel>Running loops in parallel<a hidden class=anchor aria-hidden=true href=#running-loops-in-parallel>#</a></h3><p>At first glance, looping in parallel might appear to be as simple as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>parallelLoop</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>f</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>filenames</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>f</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, when you run the function above, you will observe that the function exits almost immediately. The above doesn’t work because <code>parallelLoop()</code> returns before it has finished all its work. We have to change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>parallelLoop</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>f</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>filenames</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>f</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nx>filenames</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span><span class=nx>ch</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>One other thing worth highlighting is that the <code>f</code> is passed into the goroutine as an explicit argument as such: <code>go func(f string){...}(f)</code> and not directly used in the goroutine. Explicit parameters are used for goroutines in a loop to ensure that we use the value of <code>f</code> that is current when the go statement is executed.</p><p>However, the above example does not take error handling into consideration. Now let’s have a look at the idiomatic approach to looping in parallel using the <code>sync.WaitGroup</code> and handling errors appropriately:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeThumbnails</span><span class=p>(</span><span class=nx>filesnames</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>sizes</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>f</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>filenames</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>f</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=c1>// run operations to retrieve the size of the file
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>sizes</span> <span class=o>&lt;-</span> <span class=nx>size</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// closer
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>sizes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>total</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>size</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>sizes</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>total</span> <span class=o>+=</span> <span class=nx>size</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Above is a snippet of code where we retrieve the size of different files in parallel and compute the total size. The example used in the book can be found <a href=https://github.com/adonovan/gopl.io/blob/master/ch8/thumbnail/thumbnail_test.go#L117-L146>here</a>. There are a few things we want to pay attention from the above:</p><ol><li><code>wg.Add(1)</code> must be called before the worker goroutine starts, not within it—this ensures that the <code>Add</code> happens before the closer goroutine calls <code>Wait</code></li><li>defer is used on <code>wg.Done()</code> to ensure that Done is called even in the error cases</li><li>The closer goroutine that waits for the workers must be created before the closing of the sizes channel</li><li>The closer goroutine must be concurrent with the loop over sizes<ul><li>If the wait operation was placed before the loop in the main goroutine: it would never end</li><li>If the wait operation was placed after the loop in the main goroutine: the loop would never terminate because there is nothing closing the <code>sizes</code> channel and the wait operation will be unreachable</li></ul></li></ol><h3 id=unbounded-parallelism>Unbounded parallelism<a hidden class=anchor aria-hidden=true href=#unbounded-parallelism>#</a></h3><p>If there is a limiting factor in the system, such as the number of CPU cores, the number of spindles and heads for local disk I/O operations, or the bandwidth of the network, we want to limit the number of parallel uses of the resource to match the level of parallelism that is available.</p><p>We can limit parallelism using a buffered channel of capacity <code>n</code> to model a concurrency primitive called a <code>counting semaphore</code>. Conceptually sending a value into the channel acquires a token and receiving a value from the channel releases the token, ensuring that at most n sends can occur without an intervening receive. Let&rsquo;s have a look at an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tokens</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>tokens</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>// acquire the token
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ..
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>&lt;-</span><span class=nx>tokens</span> <span class=c1>// release the token
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Alternatively, you can use the golang <a href=https://pkg.go.dev/golang.org/x/sync/semaphore>semaphore package</a> and call <code>Acquire</code> and <code>Release</code> on the semaphore that is equivalent of the token concept above.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>var</span> <span class=nx>sem</span> <span class=p>=</span> <span class=nx>semaphore</span><span class=p>.</span><span class=nf>NewWeighted</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>sem</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// equivalent to sem &lt;- 1 (using channel approach)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>sem</span><span class=p>.</span><span class=nf>Release</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// equivalent to &lt;- sem (using channel approach)
</span></span></span></code></pre></div><p>There is a blog post that covers semaphore in greater detail <a href=https://medium.com/@deckarep/gos-extended-concurrency-semaphores-part-1-5eeabfa351ce>here</a>.</p><h3 id=multiplexing-with-select--cancellation>Multiplexing with select & cancellation<a hidden class=anchor aria-hidden=true href=#multiplexing-with-select--cancellation>#</a></h3><p>The select statement comes in handy when we need to wait for an event on one of the many channels. The select statement can be used with a ticker to run a loop every n seconds/minutes/hours as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=nx>ticker</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=o>...</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// some operations
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ticker</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Notice how we have a case for a receive operation on a <code>done</code> channel. That is useful when want the main goroutine to tell the other goroutines (above goroutine in this case) to abandon the values they are trying to send. Otherwise those goroutines with work left will be stuck trying to send their responses on a channel from which no goroutine will ever receive, leading to resource leak as mentioned earlier. In order for that to work, we will need to close the done channel at the end of the <code>main()</code> as done below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Set up a done channel that&#39;s shared by the whole pipeline,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and close that channel when this pipeline exits, as a signal
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// for all the goroutines we started to exit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>          
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// some operations
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>done</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}){</span>
</span></span><span class=line><span class=cl>			<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// done will be closed by the deferred call
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Here are a few other details about the multiplexing with the <code>select</code> statement that you might find useful:</p><ul><li>If multiple cases are ready, <code>select</code> picks one at a random.</li><li>If there is a case in the select statement where the channel can optionally be nil (depending on the flag passed in), the case is effectively disabled</li></ul><p>I hope this post has provided some context for you to get started with concurrency in Go. If you would like to learn more about them, make sure you check out <code>Chapter 8: Goroutines and Channels</code> of the <a href=https://amzn.to/45LKKfM>Go Programming Language</a> book as well as <a href=https://go.dev/blog/pipelines>The Go Blog on Go Concurrency Patterns</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://blog.bahrani.my.id/docs/sambutan/><span class=title>« Prev</span><br><span>Selamat Datang Di Blog Saya</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on x" href="https://x.com/intent/tweet/?text=Windows%20Terminal%20Dengan%20Oh-My-Posh&amp;url=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f&amp;title=Windows%20Terminal%20Dengan%20Oh-My-Posh&amp;summary=Windows%20Terminal%20Dengan%20Oh-My-Posh&amp;source=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f&title=Windows%20Terminal%20Dengan%20Oh-My-Posh"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on whatsapp" href="https://api.whatsapp.com/send?text=Windows%20Terminal%20Dengan%20Oh-My-Posh%20-%20https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on telegram" href="https://telegram.me/share/url?text=Windows%20Terminal%20Dengan%20Oh-My-Posh&amp;url=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Windows Terminal Dengan Oh-My-Posh on ycombinator" href="https://news.ycombinator.com/submitlink?t=Windows%20Terminal%20Dengan%20Oh-My-Posh&u=https%3a%2f%2fblog.bahrani.my.id%2fdocs%2fterminal%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.bahrani.my.id/>My Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>